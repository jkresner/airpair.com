#### Table of Contents
- [1 Why use ES6 Harmony](#1-why-use-es6-harmony)
- [2 ES6 features that excite me](#2-es6-features-that-excite-me)
 - [2.1 Cleaner iterator syntax](#2-1-cleaner-iterator-syntax)
 - [2.2 De-structuring assignment](#2-2-destructuring-assignment)
 - [2.3 Arrow functions](#2-3-arrow-functions) 
- [3 ES6 module pattern](#3-es6-module-pattern)
- [4 Setting up ES6 with NodeJS](#4-setting-up-es6-with-nodejs)
 - [4.1 es6-module-loader package](#4-1-es6-module-loader-package)
 - [4.2 appdir vs __dirname](#4-2-appdir-vs-dirname) 
- [5 Summary](#5-summary)

###### Author
![Jonathon Kresner](//gravatar.com/avatar/780d02a99798886da48711d8104801a4?s=100) 

> Jonathon Kresner is AirPair's CEO and Founder. He conceived AirPair to help developers build ideas faster and stay un-stuck.
> He's decided to put AirPair to the test, by rebuilding airpair.com from scratch in 90 days with daily help from the best 
> AngularJS, NodeJS and MongoDB experts on the web.

<iframe width="640" height="360" src="//www.youtube-nocookie.com/embed/pE0yd_AW_YI" frameborder="0" allowfullscreen>
</iframe>

---

## 1 Why use ES6 Harmony
ES6 is short for ECMAScript6, which is the upcoming version of JavaScript. As a language, JavaScript is a double edged sword. It can be freakingly ugly, but at the same time extremely flexible and powerful. JS code is often criticized for having un-necessary redundancy. Thus abstractions like `CoffeeScript` and `TypeScript` became very popular. I personally love writing in CoffeeScript, but CoffeeScript threatens to fragment the JavaScript community and its maintained code bases and package eco-system. So the majority of JavaScript influencers frown upon it. 

ES6 (code named Harmony) introduces some new JavaScipt language features similar to CoffeeScript. Cleaner iterators (loop syntax), arrow functions, de-structuring assignment and even classes to name a few.

## 2 ES6 features that excite me

I was immediately jazzed to regain the following similar CoffeeScript features:

### 2.1 Cleaner iterator syntax

<!--?prettify lang=javascript linenums=false?-->

    // es6 set style iterator syntax
    for (var post of posts) {
    	console.log(post.url);
    }

### 2.2 Destructuring assignment

<!--?prettify lang=javascript linenums=false?-->    
    
    var post = {
    	url: '/first-post',
    	title: 'My First Post'
    }

    // es6 de-structuring assignment (same as CoffeeScript)
    {url,title} = post;
    console.log('url', url, 'post', post);

### 2.3 Arrow functions
Arrow function in es6 are not as cool as coffee and there are differences, but it's better than nothing! Note there is only a fat arrow version (`=>`) and it does not do any magic with the function context (`this` varible)

<!--?prettify lang=javascript linenums=false?-->

    // single line arrow functions do not require braces
    app.get('posts', (req, res) => res.render('/posts.html') );

    // multi line arrow functions require braces
    app.get('posts', (req, res) => {
        console.log('in post route');
        res.render('/posts.html');
      }
    );

Braces are required in multi-line functions because unlike CoffeeScript, JavaScript does not care about indentation.

### 3 ES6 Module Pattern
As folks starting building large scale javascript apps, it became necessary to keep code organized and not conflicting in variable scope, particularly with integrating other people's code into your own app. Thus rose the `RequireJS` and `CommonJS` module patterns which power most web apps and node respectively. ES6 is the first version of JavaScript that comes with it's own native module loading pattern and syntax. It's no doubt one of the biggest features in ES6.

<!--?prettify lang=javascript linenums=false?-->

    // node style module export pattern
    module.exports = {
    	initialize: function() { ... },
    	renderPost: function(postName) { ... }
    }

    // es6 style module export pattern
    export function initialize() { ... }
    export function renderPost(postName) { ... }

<!--?prettify lang=javascript linenums=false?-->

    // node style module import pattern
    var blog = require('./blog');
    blog.initialize();

    // es6 style function import pattern
    import {initialize,renderPost} from './blog'
    initialize();
    renderPost('hello-world');

    // es6 style namespaced import pattern
    import * as blog from './blog';
    blog.initialize();
    blog.renderPost('hello-world');

## 4 Setting up ES6 with NodeJS
Setting up es6 with node is not as clean as I would have liked. We might be a little bit early adopting Harmony, but our engineering culture is ok with being on the bleeding edge with mainstream technologies. There is a flag you can pass node like `node index.js --harmony` but it only works with the current dev branch of nodejs.

### 4.1 es6-module-loader package
To get es6 working in nodejs, we can install a package `npm i es6-module-loader -S` and wrap our index.js file in a 'bootstrap' file that imports our app using the es6 module pattern setting all imported code to support es6 features.

<!--?prettify lang=javascript linenums=false?-->
    
    // bootstrap.js file

    var System = require('es6-module-loader').System;

    System.import('./index').then(function(index) {
	    index.run(__dirname);
    }).catch(function(err){
	    console.log('err', err);
    });

Note you should tack on the `catch()` promise function so you can see stack errors. 

Once we setup our `boostrap.js` file, we no longer start our app with `node index.js` but instead

    node boostrap.js

### 4.2 appdir vs __dirname
The ES6 module system mixes up the normal `\_\_dirname` node variable, so you can't mixed and match ES6 styles imports with require syntax and use relative paths. To get around this Uri showed me a solution to pass in the __dirname value from the bootstrap code (above) and then adding it in index.js for reference onto our app object like so:

<!--?prettify lang=javascript linenums=false?-->

    export function run(appdir)
    {
	    var express = require('express');
	    var app = express();
	    app.dir = appdir;
	    ...
	    app.use(express.static(app.dir + '/app'));
	    ...
    }


### 5 Summary

I was really keen to embrace ECMAScript6. I'd already fooled around for 20 minutes and got nowhere with setting up es6 on node. Uri helped me understand the bootstrapping process in 10 minutes and I know it would have taken me an hour. Especially in these cutting edge scenarios, it feels so good to leverage someone else's fiddling time. It was really run to be excited and having fun at the same time with my expert.
